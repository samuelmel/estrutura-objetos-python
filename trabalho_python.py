# -*- coding: utf-8 -*-
"""Trabalho Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17cZDN5kvmfvNUp_qZBMWe_BMG9uh5yiq

# **CODIGO QUESTAO 1 - Classe e validação robusta (POO básico)**
"""

import re

class Produto:
    def __init__(self, codigo: str,nome: str, preco: float, quantidade:int):
        self.nome = nome
        self.codigo = codigo
        self.preco = preco
        self.quantidade = quantidade

        # valida o formato do codigo
        if not re.fullmatch(r"[A-Z]{3}-\d{4}", codigo):
          raise ValueError("Insira no formato XXX-YYYY")
        # valida o valor do preço
        if preco < 0:
            raise ValueError("Preço não pode ser negativo")
        # valida o numero de quantidade
        if quantidade <= 0:
            raise ValueError("Quantidade não pode ser negativa")

    def vender(self, num: int):
      if num <= 0:
        raise ValueError("Quantidade não pode ser negativa")

      if num > self.quantidade:
        raise ValueError("Quantidade não pode ser maior que o estoque")

      # tira a quantidade da venda da quantidade do estoque
      self.quantidade -= num

      return (num * self.preco)

    def repor(self, num:int):
      self.quantidade += num

"""QUESTÃO 1 - TESTE 1




"""

pro = Produto("ABC-1234", "PANELA", 51, 20)
print(pro.vender(3))
pro.repor(8)
print(pro.quantidade)

"""QUESTÃO 1 - EXPLICAÇÃO

As validações garantem que cada objeto Produto seja criado apenas com dados corretos, evitando estados inválidos no sistema. A verificação de preço e quantidade **impede de ser usados valores negativos**, que quebrariam a lógica de estoque e vendas. Já a validação nos métodos vender e repor **impede operações impossíveis**, como vender mais que o disponível ou repor valores inválidos.

# **CODIGO QUESTÃO 2 - Herança Múltipla**
"""

import time

#classe GPS
class GPS:
  def __init__(self):
    self.gps_ligado = False

  def ligar_gps(self):
    self.gps_ligado = True

  def desligar_gps(self):
    self.gps_ligado	 = False

#class Cruise Control
class CruiseControl:
  def __init__(self):
    self.cruise_ligado = False

  def ligar_cruise(self, velocidade_alvo):
    self.cruise_ligado = True
    self.velocidade_alvo = velocidade_alvo

  def desligar_cruise(self):
    self.cruise_ligado = False
    self.velocidade_alvo = 0


class Veiculo:
  def __init__(self):
    pass


class CarroHeranca(GPS, CruiseControl, Veiculo):
  def __init__(self):
    Veiculo.__init__(self)
    GPS.__init__(self)
    CruiseControl.__init__(self)

"""# C**ODIGO QUESTÃO 2 - Composição**"""

#classe GPS
class GPSComp:
  def __init__(self):
    self.gps_ativar = False

  def ligar_gps(self):
    self.gps_ativar = True

  def desligar_gps(self):
    self.gps_ativar = False

#class Cruise Control
class CruiseControlComp:
  def __init__(self):
    self.cruise_ativar = False

  def ligar_cruise(self, velocidade_alvo):
    self.cruise_ativar = True
    self.velocidade_alvo = velocidade_alvo

  def desligar_cruise(self):
    self.cruise_ativar = False
    self.velocidade_alvo = 0


class CarroComposicao(GPS, CruiseControl):
  def __init__(self):
    self.gps = GPSComp()
    self.cruise = CruiseControlComp()

"""**QUESTÃO 2 - BENCHMARK**"""

def benchmark_heranca():
  c = CarroHeranca()
  for operacao in range(10000):
    c.ligar_gps()
    c.desligar_gps()
    c.ligar_cruise(100)
    c.desligar_cruise()

def benchmark_composicao():
  c = CarroComposicao()
  for operacao in range(10000):
    c.gps.ligar_gps()
    c.gps.desligar_gps()
    c.cruise.ligar_cruise(100)
    c.cruise.desligar_cruise()


t1 = time.perf_counter()
benchmark_heranca()
t2 = time.perf_counter()

t3 = time.perf_counter()
benchmark_composicao()
t4 = time.perf_counter()

print(f"Tempo de execução com herança múltipla: {t2 - t1} segundos")
print(f"Tempo de execução com composição: {t4 - t3} segundos")

"""QUESTÃO 2 - JUSTIFICATIVA DA ABORDAGEM

A herança múltipla funciona, mas gera **códigos mais difíceis de manter**, além de **poder criar conflitos de métodos quando várias classes têm atributos ou funções com o mesmo nome** (problema do diamante da morte). Já a composição torna a estrutura mais clara: o carro possui componentes independentes (GPS e Cruise), o que reduz acoplamento e torna os testes e a manutenção mais simples. Como o desempenho das duas abordagens é muito parecido, a decisão não é por performance, e sim por clareza e segurança. A escolha ideal seria composição, pois evita hierarquias confusas.

# **QUESTÃO 3 - Polimorfismo e coleções heterogêneas**
"""

class Documento:
  pass

class Relatorio(Documento):
  def __init__ (self, titulo):
    self.titulo = titulo
  def render(self):
    return f"[RELATORIO] {self.titulo}"


class NotaFiscal(Documento):
  def __init__ (self, numero):
    self.numero = numero
  def render(self):
    return f"[NOTA FISCAL]: {self.numero}"

class Carta (Documento):
  def __init__ (self, destinatario):
    self.destinatario = destinatario
  def render(self):
    return f"[MENSAGEM PARA] {self.destinatario}"

def processar_documentos(lista_de_documentos):
  resultados = []
  contagem = {}

  for documento in lista_de_documentos:
    resultados.append(documento.render())
    tipo = documento.__class__.__name__
    contagem[tipo] = contagem.get(tipo, 0) + 1

  return resultados, contagem

"""QUESTÃO 3 - TESTE COM DUCK-TYPING

"""

documento1 = Relatorio("Relatorio mensal")
documento2 = NotaFiscal(12345)
documento3 = Carta("Rafael")

lista_de_documentos = [documento1, documento2, documento3]

renderizados, contagem = processar_documentos(lista_de_documentos)

print(renderizados)
print(contagem)

"""QUESTÃO 3 - POR QUE TESTE COM DUCK-TYPING FAVORECE O POLIMORFISMO?

**Duck Typing** permite que a função trate qualquer objeto que tenha o método render(), sem precisar verificar o tipo com isinstance. Isso aumenta o polimorfismo porque novas classes podem ser adicionadas sem mudar a função auxiliar como a função processar_documentos. O código depende apenas do comportamento, não do tipo, tornando o sistema mais flexível.

# QUESTÃO 4 - Overriding e uso de super()
"""

class Funcionario():
  def __init__(self, nome, salario):
    self.nome = nome
    self.salario = salario

  def aumentar_salario(self, porcentagem = None):
    if porcentagem is None:
      porcentagem = 0.05
    self.salario += self.salario * porcentagem

class gerente(Funcionario):
  def aumentar_salario(self, porcentagem = None):
    if porcentagem is None:
      porcentagem = 0.1
    super().aumentar_salario(porcentagem)

class programador(Funcionario):
  def aumentar_salario(self, porcentagem = None):
    if porcentagem is None:
      porcentagem = 0.2
    super().aumentar_salario(porcentagem)

"""QUESTÃO 4 - EXEMPLOS QUE PROVAM POLIMORFISMO"""

exemplo1: Funcionario = programador("Samuel",2000)
exemplo1.aumentar_salario()
print(exemplo1.salario)

"""QUESTÃO 4 - JUSTIFICATIVA DO USO DO SUPER()

O **super()** é importante porque permite que as subclasses **reaproveitem a lógica já implementada na classe base**, evitando duplicação de código. Assim, cada subclasse apenas altera o comportamento necessário, enquanto a fórmula do aumento permanece centralizada na superclasse. Isso mantém o código mais limpo, fácil de manter e reduz erros.

# **QUESTÃO 5 - Conta bancária com regras e testes de estresse**
"""

import datetime
import threading
from concurrent.futures import ThreadPoolExecutor

class Conta:
    def __init__(self, titular, saldo_inicial):
        self.titular = titular
        self.saldo = saldo_inicial
        self.historico = []
        self.lock = threading.Lock()

    def transferir(self, outra_conta, valor):
        primeira, segunda = (self, outra_conta) if id(self) < id(outra_conta) else (outra_conta, self)

        with primeira.lock:
            with segunda.lock:
                saldo_original_self = self.saldo
                saldo_original_outro = outra_conta.saldo
                hist_self = list(self.historico)
                hist_outro = list(outra_conta.historico)

                try:
                    if valor <= 0:
                        raise ValueError("Valor inválido")
                    if self.saldo < valor:
                        raise ValueError("Saldo insuficiente")

                    self.saldo -= valor
                    outra_conta.saldo += valor

                    self.historico.append(
                        (datetime.datetime.now(), "TRANSFERENCIA-SAIDA", valor, self.saldo)
                    )
                    outra_conta.historico.append(
                        (datetime.datetime.now(), "TRANSFERENCIA-ENTRADA", valor, outra_conta.saldo)
                    )

                except Exception:
                    self.saldo = saldo_original_self
                    outra_conta.saldo = saldo_original_outro
                    self.historico = hist_self
                    outra_conta.historico = hist_outro
                    raise


class ContaEspecial(Conta):
    def __init__(self, titular, salario, saldo_inicial=0):
        super().__init__(titular, saldo_inicial)
        self.limite = salario * 3

    def transferir(self, outra_conta, valor):
        primeira, segunda = (self, outra_conta) if id(self) < id(outra_conta) else (outra_conta, self)

        with primeira.lock:
            with segunda.lock:
                saldo_original_self = self.saldo
                saldo_original_outro = outra_conta.saldo
                hist_self = list(self.historico)
                hist_outro = list(outra_conta.historico)

                try:
                    if valor <= 0:
                        raise ValueError("Valor inválido")
                    if self.saldo + self.limite < valor:
                        raise ValueError("Limite excedido")

                    self.saldo -= valor
                    outra_conta.saldo += valor

                    self.historico.append(
                        (datetime.datetime.now(), "TRANSFERENCIA-ESPECIAL-SAIDA", valor, self.saldo)
                    )
                    outra_conta.historico.append(
                        (datetime.datetime.now(), "TRANSFERENCIA-ENTRADA", valor, outra_conta.saldo)
                    )

                except Exception:
                    self.saldo = saldo_original_self
                    outra_conta.saldo = saldo_original_outro
                    self.historico = hist_self
                    outra_conta.historico = hist_outro
                    raise

"""QUESTÃO 5 - TESTES"""

def teste():
    c1 = Conta("Pedro", 8000)
    c2 = Conta("Caio", 3000)

    saldo_total_inicial = c1.saldo + c2.saldo

    def operacao():
        try:
            c1.transferir(c2, 5)
            c2.transferir(c1, 5)
        except:
            pass

    with ThreadPoolExecutor(max_workers=20) as executor:
        for _ in range(1000):
            executor.submit(operacao)

    saldo_total_final = c1.saldo + c2.saldo

    print("Saldo inicial:", saldo_total_inicial)
    print("Saldo final:  ", saldo_total_final)
    print("Consistente?: ", saldo_total_final == saldo_total_inicial)


teste()

"""QUESTÃO 5 - EXPLICAÇÃO DE PYTHON(GIL)

Em Python, **threads não executam bytecode realmente em paralelo por causa do GIL**, que permite apenas um thread rodar por vez. Isso reduz condições reais de corrida, então o teste simula concorrência, mas não a reproduz de forma completa. Em linguagens sem GIL, como Java ou Go, seria necessário usar travas mais robustas, pois a chance de **race conditions** seria maior.

# **QUESTÃO 6 - Implementação de método especial (__str__, __eq__, __add__)**
"""

import math

class Vetor2D():
  def __init__(self, x, y):
    self.x = float(x)
    self.y = float(y)

  def __str__(self):
    return f"{self.x}, {self.y}"

  def __eq__(self, outro):
      return abs(self.x - outro.x) < 1e-9 and abs(self.y - outro.y) < 1e-9

  def __add__(self, outro):
    return Vetor2D(self.x + outro.x, self.y + outro.y)

  def angle_with(self, outro):
    ponto = self.x * outro.x + self.y * outro.y
    mag1 = math.sqrt(self.x**2 + self.y**2)
    mag2 = math.sqrt(outro.x**2 + outro.y**2)

    if mag1 == 0 or mag2 == 0:
            return 0.0

    cos_theta = ponto / (mag1 * mag2)

    cos_theta = max(-1, min(1, cos_theta))

    return math.degrees(math.acos(cos_theta))

"""QUESTÃO 6 - TESTES"""

v1 = Vetor2D(1, 2)
v2 = Vetor2D(3, 4)
assert v1 + v2 == v2 + v1

v3 = Vetor2D(1.0000000001, 2.0)
v4 = Vetor2D(1.0, 2.0)
assert v3 == v4

v5 = Vetor2D(8, -9)
assert abs(v5.angle_with(v5)) < 1e-9

print("os testes deu bom")

"""CODIGO 6 - JUSTIFICATIVAS

As validações de igualdade usam tolerância numérica porque operações com FLOAT produzem pequenas imprecisões, então comparar valores exatos quebraria muitos testes. A sobrecarga de __add__ garante uma soma vetorial intuitiva e compatível com o modelo matemático. O método angle_with segue a definição clássica de ângulo entre vetores usando produto escalar e normas, com correção numérica para manter o valor do cosseno dentro do intervalo válido. Esses cuidados garantem estabilidade, precisão e comportamento matematicamente correto.
"""